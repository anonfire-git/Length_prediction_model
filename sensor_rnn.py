# -*- coding: utf-8 -*-
"""Sensor_RNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EU_Tb4yv_zYVq2S4UYZsyDbCBsBwFHim
"""

# Commented out IPython magic to ensure Python compatibility.
# %env KERAS_BACKEND = tensorflow
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
#from sklearn.preprocessing import MinMaxScaler
from matplotlib import animation, rc
from IPython.display import HTML
import matplotlib

pd.set_option('max_rows', 99999)

dori = pd.read_csv("training.csv")
dori.head()

res = dori["res"].values
dis = dori["dis"].values
res = (res - np.min(res))/(np.max(res)-np.min(res))
dis = (dis - np.min(dis))/(np.max(dis)-np.min(dis))

def normalize(df):
    norm = df.apply(lambda x: (x - np.min(x)) / (np.max(x) - np.min(x)))
    return norm

dori = normalize(dori)
dori

predict_data = 1
ref_data = 1
X_train, Y_train = [], []
for i in range(500,4281):
  X_train.append(np.array(dori.iloc[i:i+ref_data,4:5]))
  Y_train.append(np.array(dori.iloc[i:i+ref_data,3:4]))

X_train = np.array(X_train)
Y_train = np.array(Y_train)

#C_train = []
#for i in range(dori.shape[0]-predict_data-ref_data):
 # C_train.append(np.column_stack((dori.iloc[[i+ref_data],[1]].values,[0])))

#C_train = np.array(C_train)
#C_train.shape

#O_train = np.column_stack((X_train,C_train))
#O_train[0]

#example
#Z_train = np.row_stack((X_train[0],np.column_stack((dori.iloc[[5],[1]].values,[0]))))
#a = np.array(dori.iloc[0:5,1:3])
#b = np.array(dori.iloc[5:6,2:3])
#c = dori.iloc[[5],[1]].values
#d = np.column_stack((dori.iloc[[5],[1]].values,[0]))
#print(a)
#print(b)
#print(c)
#print(d)

X_train[0]

Y_train[0]

from keras.models import Sequential
from keras.layers import Activation, Dropout, Flatten, Dense
from keras.layers import LSTM

model = Sequential()
model.add(LSTM(150, input_shape=(1, 1), return_sequences=True))
model.add(LSTM(150,return_sequences=True))
model.add(LSTM(150))
model.add(Dropout(0.1))
model.add(Dense(5, activation='sigmoid'))
model.add(Dense(1))
model.compile(loss="mse", optimizer="adam")
model.summary()

#X_train = X_train.reshape((X_train.shape[0],X_train.shape[1],2))
Y_train.shape

history = model.fit(X_train, Y_train, epochs=100, batch_size=32, validation_split=0.1, shuffle=True)

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])

predict = model.predict(X_train)

predict[0]

Y_train[0]

Y_train.shape

predict.shape

ndis = np.delete(dis,range(0,500))
ndis.shape

ndis[0]

predict = predict.reshape(3781,)
#new_res = np.delete(res,[0,1])
#new_res.shape

#plt.figure(dpi=200)
plt.figure(figsize=(10,5))
plt.plot(ndis)
plt.plot(predict)

X_train = X_train.reshape(3781,)
plt.figure(figsize=(10,5))
plt.plot(X_train)

#import test data
dtest = pd.read_csv("0_15.csv")

t_res = dtest["res"].values
t_dis = dtest["dis"].values
t_res = (t_res - np.min(t_res))/(np.max(t_res)-np.min(t_res))
t_dis = (t_dis - np.min(t_dis))/(np.max(t_dis)-np.min(t_dis))

dtest = normalize(dtest)
dtest.head()

X_test, Y_test = [], []
for i in range(dtest.shape[0]-ref_data):
  X_test.append(np.array(dtest.iloc[i:i+ref_data,1:3]))
  Y_test.append(np.array(dtest.iloc[i+ref_data:i+ref_data+predict_data,2:3]))

X_test = np.array(X_test)
Y_test = np.array(Y_test)

test_predict = model.predict(X_test)

X_test.shape

test_predict = test_predict.reshape(462,)
nt_res = np.delete(t_res,[0])

f = np.hstack((t_dis[:,np.newaxis], t_res[:, np.newaxis]))
pf = np.hstack((test_predict[:,np.newaxis], nt_res[:, np.newaxis]))
pf.shape

plt.figure(figsize=(12,8))
plt.scatter(t_dis,t_res,s=60, c="grey")
plt.scatter(test_predict,nt_res, c="r",s=40)
plt.axis([-0.04,1.04,-0.04,1.04])
#---------------------------------------------------

fig, ax = plt.subplots(figsize=(10,7))
plt.close()
ax.set_xlim(( -0.04, 1.04))
ax.set_ylim((-0.04, 1.04))
scat = ax.scatter([],[], s=200, c="r", zorder=3)
scat2 = ax.scatter([],[], s=50, c="grey", alpha=0.6, zorder=1)
scat3 = ax.scatter([],[], s=20, c="green", zorder=2)

def init():
    scat2.set_offsets(f)
    scat3.set_offsets(pf)      
    return scat2, scat3,

def animate(i):
    scat.set_offsets(f[i])
    return scat,


anim = animation.FuncAnimation(fig, animate, init_func=init, frames=len(t_dis), interval=13, repeat=True)
rc('animation', html='jshtml')
anim

nt_dis = np.delete(t_dis,[0])
plt.plot((test_predict-nt_dis)/nt_dis, c="purple")
plt.ylim(ymax = 30)

#model.save('sensor_rnn.h5')

